________
Path: README.md
Content:
# LLM-FileProcessor

LLM-CodeInject is a command-line tool written in Go that processes files in a specified directory based on given criteria. It's designed to integrate seamlessly with Language Learning Models (LLMs) for extracting smaller code components.

## Features
- Specify root directory
- Ignore specific directories
- Exclude files with specific extensions
- Include only files with specific extensions
- Process and display contents of text files

## Installation

### Prerequisites
- Go 1.16 or later

### Steps
1. Clone the repository:
    ```sh
    git clone https://github.com/yourusername/llm-fileprocessor.git
    ```
2. Navigate to the project directory:
    ```sh
    cd llm-codeinject
    ```
3. Build the project:
    ```sh
    ./build.sh
    ```

## Usage

### Basic Command
```sh
./llm-codeinject --directory /path/to/dir --ignore-dir logs,temp --ignore-ext log,tmp --include-ext txt,md
```

### Flags Explanation
- `--dir` or `-dir`: Comma-separated list of directories to search (default: current directory).
- `--ignore-file` or `-ignore-file`: Comma-separated list of files to ignore.
- `--ignore-dir` or `-ignore-dir`: Comma-separated list of directories to ignore.
- `--ignore-ext` or `-ignore-ext`: Comma-separated list of file extensions to ignore.
- `--include-ext` or `-include-ext`: Comma-separated list of file extensions to include.
- `--recursive` or `-recursive`: Recursively search directories (default: true).
- `--debug` or `-debug`: Enable debug output.
- `--save` or `-save`: Save the output to a file.
- `--output-file` or `-output-file`: Specify the output file name (default: output.txt).
- `--show-size` or `-show-size`: Show the size of the result in bytes.
- `--show-funcs` or `-show-funcs`: Show only functions and their parameters.

### Internal Use Examples

#### Frontend
```sh
llm-codeinject -dir social-network-frontend -ignore-file package-lock.json -ignore-dir node_modules,__previewjs__ -ignore-ext svg,png,ico,md -output-file frontend.txt -save
```

#### Backend
```sh
llm-codeinject -dir social-network-backend -ignore-file package-lock.json,auth_test.go -ignore-dir tests -ignore-ext sum,mod -output-file backend.txt -save
```

#### Debugging
```sh
llm-codeinject -debug -dir . -ignore-file package-lock.json,llm-codeinject,frontend.txt -ignore-dir cmd,pkg,.idea,.git,node_modules,__previewjs__ -ignore-ext svg,png,ico,md -output-file frontend.txt -save
```

## Development

The code has been refactored to improve modularity and testability using functional programming principles. Key changes include:

- **Configuration Parsing**: Decoupled from the main function for better readability and testability.
- **File Processing**: Extracted into a separate function to simplify the main function.
- **Functional Style**: Refactored file handling using higher-order functions.
- **Debug Information**: Improved handling using a functional approach.
- **Utility Functions**: Consolidated into a single module for improved organization and reusability.

### Testing

To ensure the code is easy to test, functional parameters are used for gathering and processing files, allowing easy mocking during tests. Each function handles a single responsibility, making the codebase modular and maintainable.

## Contributing

Contributions are welcome! Please submit a pull request or open an issue to discuss any changes.

## License

This project is licensed under the MIT License.

________
Path: build.sh
Content:
#!/bin/bash

# Build the Go project
go build -o llm-codeinject ./cmd/main.go

# Make the binary executable
chmod +x llm-codeinject

# Add the binary to the PATH (Optional: Adjust the path as per your setup)
echo "export PATH=\$PATH:$(pwd)" >> ~/.bashrc

# For zsh, also add it to ~/.zshrc
echo "export PATH=\$PATH:$(pwd)" >> ~/.zshrc

# Source both .bashrc and .zshrc
source ~/.bashrc
source ~/.zshrc

________
Path: cmd/main.go
Content:
package main

import (
	"fmt"
	"strings"

	"llm-codeinject/config"
	"llm-codeinject/filehandling"
	"llm-codeinject/processing"
	"llm-codeinject/utils"
)

func main() {
	cfg := config.ParseConfig()

	if cfg.Debug {
		utils.PrintDebugInfo(cfg)
	}

	output := processFiles(cfg, filehandling.GatherIncludedFiles, processing.ProcessFiles, processing.DefaultProcessFunc)

	if cfg.Save {
		if err := utils.SaveOutput(cfg.OutputFile, output.String()); err != nil {
			fmt.Printf("Error saving output to file %q: %v\n", cfg.OutputFile, err)
		}
	}

	if cfg.ShowSize {
		if err := utils.DisplaySize(strings.Split(output.String(), "\n")); err != nil {
			fmt.Printf("Error displaying size: %v\n", err)
		}
	} else {
		fmt.Print(output.String())
	}
}

func processFiles(cfg *config.Config, gatherFunc func(string, string, string, string, bool) ([]string, error), processFunc func([]string, *strings.Builder, func(string) ([]byte, error)), fileProcessFunc func(string) ([]byte, error)) strings.Builder {
	var output strings.Builder

	if cfg.ShowFuncs {
		filehandling.ProcessDirectories(cfg.Dirs, processing.ShowFunctions, cfg)
		return output
	}

	includedFiles, err := gatherFunc(cfg.Dirs, cfg.IgnoreFiles, cfg.IgnoreDirs, cfg.IgnoreExts, cfg.Debug)
	if err != nil {
		fmt.Printf("Error gathering included files: %v\n", err)
		return output
	}

	if cfg.Debug {
		fmt.Println("Included files:")
		for _, file := range includedFiles {
			fmt.Println(file)
		}
	}

	processFunc(includedFiles, &output, fileProcessFunc)
	return output
}

________
Path: config/config.go
Content:
package config

import "flag"

type Config struct {
	Dirs        string
	IgnoreFiles string
	IgnoreDirs  string
	IgnoreExts  string
	Recursive   bool
	Debug       bool
	Save        bool
	OutputFile  string
	ShowSize    bool
	ShowFuncs   bool
}

func NewConfig() *Config {
	return &Config{}
}

func (c *Config) ParseFlags() {
	flag.StringVar(&c.Dirs, "dir", ".", "Comma-separated list of directories to search")
	flag.StringVar(&c.IgnoreFiles, "ignore-file", "", "Comma-separated list of files to ignore")
	flag.StringVar(&c.IgnoreDirs, "ignore-dir", "", "Comma-separated list of directories to ignore")
	flag.StringVar(&c.IgnoreExts, "ignore-ext", "", "Comma-separated list of file extensions to ignore")
	flag.BoolVar(&c.Recursive, "recursive", true, "Recursively search directories")
	flag.BoolVar(&c.Debug, "debug", false, "Enable debug output")
	flag.BoolVar(&c.Save, "save", false, "Save the output to a file")
	flag.StringVar(&c.OutputFile, "output-file", "output.txt", "Specify the output file name")
	flag.BoolVar(&c.ShowSize, "show-size", false, "Show the size of the result in bytes")
	flag.BoolVar(&c.ShowFuncs, "show-funcs", false, "Show only functions and their parameters")
	flag.Parse()
}

func ParseConfig() *Config {
	cfg := NewConfig()
	cfg.ParseFlags()
	return cfg
}

________
Path: filehandling/filehandling.go
Content:
package filehandling

import (
	"llm-codeinject/config"
	"os"
	"path/filepath"
	"strings"
)

func ValidateDirectory(dir string) bool {
	info, err := os.Stat(dir)
	return err == nil && info.IsDir()
}

func GatherIncludedFiles(dirs, ignoreFiles, ignoreDirs, ignoreExts string, debug bool) ([]string, error) {
	var files []string
	dirList := strings.Split(dirs, ",")
	for _, dir := range dirList {
		if err := filepath.Walk(dir, createWalkFunc(ignoreFiles, ignoreDirs, ignoreExts, &files, debug)); err != nil {
			return nil, err
		}
	}
	return files, nil
}

func ProcessDirectories(dirs string, processFunc filepath.WalkFunc, cfg *config.Config) error {
	dirList := strings.Split(dirs, ",")
	for _, dir := range dirList {
		if err := filepath.Walk(dir, processFunc); err != nil {
			return err
		}
	}
	return nil
}

func createWalkFunc(ignoreFiles, ignoreDirs, ignoreExts string, files *[]string, debug bool) filepath.WalkFunc {
	return func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}
		if info.IsDir() && shouldSkipDir(path, ignoreDirs) {
			if debug {
				println("Skipping directory:", path)
			}
			return filepath.SkipDir
		}
		if !info.IsDir() && shouldIncludeFile(path, info, ignoreFiles, ignoreExts) {
			if debug {
				println("Including file:", path)
			}
			*files = append(*files, path)
		} else if debug {
			println("Excluding file:", path)
		}
		return nil
	}
}

func shouldSkipDir(path, ignoreDirs string) bool {
	ignoreDirsList := strings.Split(ignoreDirs, ",")
	for _, dir := range ignoreDirsList {
		if strings.Contains(filepath.ToSlash(path), filepath.ToSlash(dir)) {
			return true
		}
	}
	return false
}

func shouldIncludeFile(path string, info os.FileInfo, ignoreFiles, ignoreExts string) bool {
	ignoreFilesList := strings.Split(ignoreFiles, ",")
	ignoreExtsList := strings.Split(ignoreExts, ",")
	return !contains(ignoreFilesList, info.Name()) && !containsExt(ignoreExtsList, filepath.Ext(info.Name()))
}

func contains(list []string, item string) bool {
	for _, i := range list {
		if i == item {
			return true
		}
	}
	return false
}

func containsExt(list []string, ext string) bool {
	ext = strings.TrimPrefix(ext, ".")
	for _, e := range list {
		if e == ext {
			return true
		}
	}
	return false
}

________
Path: go.mod
Content:
module llm-codeinject

go 1.22

________
Path: go.sum
Content:

________
Path: llm-codeinject.txt
Content:

________
Path: pkg/llm-codeinject/llm-codeinject.go
Content:
package llm_codeinject

import (
	"io/ioutil"
	"os"
	"path/filepath"
	"strings"
)

// ValidateDirectory checks if a directory exists
func ValidateDirectory(dir string) bool {
	info, err := os.Stat(dir)
	if os.IsNotExist(err) {
		return false
	}
	return info.IsDir()
}

// FilterFiles filters files by directory and extensions
func FilterFiles(root string, ignoreDirs []string, ignoreExts []string, includeExts []string) ([]string, error) {
	var files []string
	err := filepath.Walk(root, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}

		// Check if the path contains any directory we need to ignore
		for _, dir := range ignoreDirs {
			if strings.Contains(filepath.ToSlash(path), filepath.ToSlash(dir)) {
				if info.IsDir() {
					return filepath.SkipDir
				}
				return nil
			}
		}

		// If it's a file, apply extension filters
		if !info.IsDir() {
			ext := strings.TrimPrefix(filepath.Ext(path), ".")
			if len(ignoreExts) > 0 && contains(ignoreExts, ext) {
				return nil
			}
			if len(includeExts) == 0 || contains(includeExts, ext) {
				files = append(files, path)
			}
		}

		return nil
	})
	return files, err
}

// ProcessFiles processes each file found
func ProcessFiles(files []string) {
	for _, file := range files {
		if file != "" {
			println("Processing file:", file)
			content, err := ioutil.ReadFile(file)
			if err != nil {
				println("Error reading file:", err)
				continue
			}
			println("Contents of file:", file)
			println(string(content))
		}
	}
}

// Helper function to check if a slice contains a string
func contains(slice []string, item string) bool {
	for _, s := range slice {
		if s == item {
			return true
		}
	}
	return false
}

________
Path: processing/processing.go
Content:
package processing

import (
	"fmt"
	"io/ioutil"
	"os"
	"regexp"
	"strings"
)

func ProcessFiles(files []string, output *strings.Builder, processFunc func(string) ([]byte, error)) {
	for _, file := range files {
		content, err := processFunc(file)
		if err != nil {
			fmt.Printf("Error processing file %s: %v\n", file, err)
			continue
		}
		output.WriteString(fmt.Sprintf("________\nPath: %s\nContent:\n%s\n", file, content))
	}
}

func DefaultProcessFunc(file string) ([]byte, error) {
	return ioutil.ReadFile(file)
}

func ShowFunctions(path string, info os.FileInfo, err error) error {
	if err != nil {
		return err
	}

	if !info.IsDir() && strings.HasSuffix(info.Name(), ".go") {
		fileContent, err := ioutil.ReadFile(path)
		if err != nil {
			fmt.Printf("Error reading file %s: %v\n", path, err)
			return nil
		}

		functions := extractFunctions(fileContent)
		if len(functions) > 0 {
			fmt.Printf("Functions in file %s:\n", path)
			for _, f := range functions {
				fmt.Println(f)
			}
		}
	}
	return nil
}

func extractFunctions(content []byte) []string {
	var functions []string
	re := regexp.MustCompile(`func\s+([a-zA-Z_][a-zA-Z0-9_]*)\s*\(([^)]*)\)`)
	matches := re.FindAllSubmatch(content, -1)
	for _, match := range matches {
		functionName := string(match[1])
		parameters := string(match[2])
		functions = append(functions, fmt.Sprintf("%s(%s)", functionName, parameters))
	}
	return functions
}

________
Path: qodana.yaml
Content:
#-------------------------------------------------------------------------------#
#               Qodana analysis is configured by qodana.yaml file               #
#             https://www.jetbrains.com/help/qodana/qodana-yaml.html            #
#-------------------------------------------------------------------------------#
version: "1.0"

#Specify inspection profile for code analysis
profile:
  name: qodana.starter

#Enable inspections
#include:
#  - name: <SomeEnabledInspectionId>

#Disable inspections
#exclude:
#  - name: <SomeDisabledInspectionId>
#    paths:
#      - <path/where/not/run/inspection>

#Execute shell command before Qodana execution (Applied in CI/CD pipeline)
#bootstrap: sh ./prepare-qodana.sh

#Install IDE plugins before Qodana execution (Applied in CI/CD pipeline)
#plugins:
#  - id: <plugin.id> #(plugin id can be found at https://plugins.jetbrains.com)

#Specify Qodana linter for analysis (Applied in CI/CD pipeline)
linter: jetbrains/qodana-go:latest

________
Path: utils/utils.go
Content:
package utils

import (
	"fmt"
	"os"

	"llm-codeinject/config"
)

func SaveOutput(filename, data string) error {
	if err := os.WriteFile(filename, []byte(data), 0644); err != nil {
		return fmt.Errorf("failed to save output to %s: %w", filename, err)
	}
	return nil
}

func DisplaySize(files []string) error {
	var totalSize int64
	for _, file := range files {
		info, err := os.Stat(file)
		if err != nil {
			return fmt.Errorf("failed to stat file %s: %w", file, err)
		}
		totalSize += info.Size()
	}

	switch {
	case totalSize < 1024:
		fmt.Printf("Output size: %d bytes\n", totalSize)
	case totalSize < 1024*1024:
		fmt.Printf("Output size: %.2f KB\n", float64(totalSize)/1024)
	default:
		fmt.Printf("Output size: %.2f MB\n", float64(totalSize)/(1024*1024))
	}
	return nil
}

func PrintDebugInfo(cfg *config.Config) {
	fmt.Println("Debug mode enabled v_0.1")
	fmt.Printf("Directories: %s\n", cfg.Dirs)
	fmt.Printf("Ignore files: %s\n", cfg.IgnoreFiles)
	fmt.Printf("Ignore directories: %s\n", cfg.IgnoreDirs)
	fmt.Printf("Ignore extensions: %s\n", cfg.IgnoreExts)
	fmt.Printf("Recursive: %v\n", cfg.Recursive)
}

